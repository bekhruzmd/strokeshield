<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Stroke Detection Application using MediaPipe"
    />
    <title>Stroke Detection App</title>
    <!-- Include MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <!-- Include Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="speech-recognition.js" defer></script>
    <style>
      .detection-container {
        position: relative;
      }
      .detection-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .metric-card {
        background-color: white;
        border-radius: 0.5rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        padding: 1rem;
        margin-bottom: 1rem;
      }
      .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
      }
      .metric-label {
        color: #6b7280;
        font-size: 0.875rem;
      }
    </style>
  </head>
  <body class="bg-gray-100 font-sans">
    <header class="bg-blue-600 text-white p-4">
      <div class="container mx-auto flex justify-between items-center">
        <div class="flex items-center gap-x-2">
          <div>
            <img src="logo.png" alt="StrokeShield Logo" class="h-32 w-40">
          </div>
          <div>
            <h1 class="text-3xl font-bold">StrokeShield</h1>
            <p class="mt-2 text-sm">Real-time analysis of facial asymmetry, body posture, and voice recognition</p>
          </div>
        </div>
        <div>
          <h1 class="text-xl font-bold text-italic">Keep your head and body straight for best results</h1>
        </div>
      </div>
    </header>
    
    <main class="container mx-auto p-4">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div class="bg-white rounded-lg shadow-lg p-4">
          <h2 class="text-xl font-bold mb-4">Camera Input</h2>
          <div class="detection-container">
            <video id="webcam" autoplay playsinline class="w-full h-auto rounded" style="max-height: 480px;"></video>
            <canvas id="detection-canvas" class="detection-canvas" width="640" height="480"></canvas>
          </div>
          <div class="mt-4 flex gap-2">
            <button 
              id="detection-toggle"
              class="px-4 py-2 rounded font-bold bg-green-500 text-white"
            >
              Start Detection
            </button>
            <button 
              id="clear-results"
              class="px-4 py-2 bg-gray-300 rounded font-bold"
            >
              Clear Results
            </button>
          </div>
          <div class="mt-2 flex flex-wrap gap-2">
            <div class="flex items-center">
              <input type="checkbox" id="face-mesh-toggle" class="mr-2" checked>
              <label for="face-mesh-toggle">Show Face Mesh</label>
            </div>
            <div class="flex items-center ml-4">
              <input type="checkbox" id="pose-toggle" class="mr-2">
              <label for="pose-toggle">Show Pose Detection</label>
            </div>
            <div class="flex items-center ml-4">
              <input type="checkbox" id="symmetry-line-toggle" class="mr-2" checked>
              <label for="symmetry-line-toggle">Show Symmetry Line</label>
            </div>
          </div>
          <div class="mt-2 flex items-center">
            <label for="detection-sensitivity" class="mr-2">Detection Sensitivity:</label>
            <input type="range" id="detection-sensitivity" min="1" max="10" value="5" class="w-32">
            <span id="sensitivity-value" class="ml-2">5</span>
          </div>
          <div class="p-4">  <!-- Detection Results Container -->
            <h2 class="text-xl font-bold mb-4">Detection Results</h2>

            <!-- Risk Level Indicator -->
            <div class="mb-6">
              <h3 class="text-lg font-semibold mb-2">Risk Assessment</h3>
              <div id="risk-indicator" class="px-4 py-2 rounded text-white font-bold text-center bg-gray-500">
                Awaiting Analysis
              </div>
            </div>

            <!-- Visualization -->
            <div class="mb-6">
              <h3 class="text-lg font-semibold mb-2">Asymmetry Metrics</h3>
              <div class="bg-white rounded-lg p-2 shadow-inner">
                <canvas id="metrics-chart" height="200"></canvas>
              </div>
            </div>

            <!-- Metrics Grid -->
            <div class="grid grid-cols-2 gap-4 mb-6">
              <div class="metric-card">
                <div class="metric-label">Eye Asymmetry</div>
                <div id="eye-asymmetry" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Mouth Asymmetry</div>
                <div id="mouth-asymmetry" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Eyebrow Asymmetry</div>
                <div id="eyebrow-asymmetry" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Overall Asymmetry</div>
                <div id="overall-asymmetry" class="metric-value">N/A</div>
              </div>
            </div>

            <!-- Posture Metrics -->
            <div class="grid grid-cols-2 gap-4 mb-6">
              <div class="metric-card">
                <div class="metric-label">Shoulder Imbalance</div>
                <div id="shoulder-imbalance" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Head Tilt</div>
                <div id="head-tilt" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Body Lean</div>
                <div id="body-lean" class="metric-value">N/A</div>
              </div>
            </div>

            <!-- Findings -->
            <div>
              <h3 class="text-lg font-semibold mb-2">Key Findings</h3>
              <ul id="findings-list" class="list-disc pl-5">
                <li>No findings yet. Start detection to analyze facial asymmetry and posture.</li>
              </ul>
            </div>

            <!-- Disclaimer -->
            <div class="mt-6 text-sm text-gray-600 bg-gray-100 p-3 rounded">
              <strong>Disclaimer:</strong> This tool is not a medical device and should not be used for medical diagnosis. 
              If you suspect a stroke, call emergency services immediately (911 in the US). 
              Remember the FAST method: Facial drooping, Arm weakness, Speech difficulties, Time to call emergency services.
            </div>
          </div>
        </div>
        
        
        <div class="bg-white rounded-lg shadow-lg p-4">
          <h2 class="text-xl font-bold mb-4">Speech Analysis</h2>
          <div class="mb-6">
            <h3 class="text-lg font-semibold mb-2">Voice Recognition</h3>
            <div class="mb-4">
              <button id="start-recording" class="px-4 py-2 rounded font-bold bg-blue-500 text-white">Start Recording</button>
              <button id="stop-recording" class="px-4 py-2 rounded font-bold bg-red-500 text-white ml-2" disabled>Stop Recording</button>
            </div>
            <div class="mb-4">
              <div class="bg-gray-100 p-3 rounded">
                <p id="recording-status">Click "Start Recording" to begin speech analysis.</p>
              </div>
            </div>
            <div class="mb-4">
              <h4 class="font-medium mb-2">Reading Passage:</h4>
              <div id="reading-passage" class="bg-blue-50 border-l-4 border-blue-500 p-3 rounded min-h-[100px] text-gray-700">
                Please read the following passage aloud when recording:
              </div>
              <div class="mt-2 flex">
                <button id="new-passage" class="px-3 py-1 text-sm rounded bg-gray-200 hover:bg-gray-300">New Passage</button>
              </div>
            </div>
            <div class="mb-4">
              <h4 class="font-medium mb-2">Your Speech Transcript:</h4>
              <div id="transcript" class="bg-gray-100 p-3 rounded min-h-[100px] max-h-[200px] overflow-y-auto"></div>
            </div>
          
          <!-- Speech Analysis Results -->
          <div class="mb-6">
            <h3 class="text-lg font-semibold mb-2">Speech Analysis Results</h3>
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div class="metric-card">
                <div class="metric-label">Speech Coherence</div>
                <div id="speech-coherence" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Slurred Speech</div>
                <div id="slurred-speech" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Word Finding</div>
                <div id="word-finding" class="metric-value">N/A</div>
              </div>
              <div class="metric-card">
                <div class="metric-label">Speech Risk Level</div>
                <div id="speech-risk" class="metric-value">N/A</div>
              </div>
            </div>
            
            <div>
              <h4 class="font-medium mb-2">Observations:</h4>
              <ul id="speech-observations" class="list-disc pl-5">
                <li>No analysis yet. Record speech to analyze patterns.</li>
              </ul>
            </div>
          </div>
          
          <!-- Past Speech Analyses -->
          <div>
            <h3 class="text-lg font-semibold mb-2">Recent Analyses</h3>
            <div id="recent-speech-analyses" class="space-y-2">
              <p>No previous analyses available.</p>
            </div>
          </div>
        </div>
      </div>

        <div class="p-4 bg-white rounded-lg shadow-lg border">
          <h2 class="text-xl font-bold text-blue-600">üß† Stroke Detection Guide</h2>
          <p class="text-gray-700 m-2">Follow these simple steps to get the most accurate results:</p>

          <div class="bg-gray-50 border border-gray-200 rounded-xl p-3 mb-2">
            <p class="font-medium">üòä <strong>Try Smiling</strong></p>
            <ul class="list-disc pl-5 mt-1">
              <li>Look directly into the camera</li>
              <li>Give a big, natural smile</li>
              <li>We're checking for symmetry in your expression</li>
            </ul>
          </div>

          <div class="bg-gray-50 border border-gray-200 rounded-xl p-3 mb-2">
            <p class="font-medium">üôã <strong>Raise Both Arms</strong></p>
            <ul class="list-disc pl-5 mt-1">
              <li>Lift both arms up to shoulder level</li>
              <li>Hold them there for a few seconds</li>
              <li>We're watching for any imbalance or drift</li>
            </ul>
          </div>

          <div class="bg-gray-50 border border-gray-200 rounded-xl p-3 mb-2">
            <p class="font-medium">üó£Ô∏è <strong>Read This Out Loud</strong></p>
            <ul class="list-disc pl-5 mt-1">
              <li>Click the <em>Start Recording</em> button</li>
              <li>Read: <em>"She sells seashells by the seashore"</em></li>
              <li>Speak clearly and at a normal pace</li>
            </ul>
          </div>

          <div class="bg-blue-50 border border-blue-200 rounded-xl p-3 mb-2">
            <p class="font-medium">ü™û <strong>Bonus Tip</strong></p>
            <p class="mt-1">Keep your head and body straight. Avoid leaning ‚Äî it helps improve detection accuracy!</p>
          </div>

          <div class="bg-green-50 border border-green-200 rounded-xl p-3 mb-4">
            <p class="font-medium">‚úÖ <strong>You're All Set!</strong></p>
            <p class="mt-1">Once you're done, StrokeShield will analyze your results and let you know if anything seems off.</p>
          </div>
          <h2 class="text-xl font-semibold text-red-600 mb-2">
            üö® What to Do If a Stroke Is Detected
          </h2>

          <div class="space-y-4 text-xl text-gray-700">

            <div class="bg-red-50 border border-red-200 rounded-xl p-3">
              <p class="font-semibold text-red-700 mb-1">üî¥ Remember FAST:</p>
              <ul class="list-disc pl-5">
                <li><strong>F</strong> ‚Äì Face drooping</li>
                <li><strong>A</strong> ‚Äì Arm weakness</li>
                <li><strong>S</strong> ‚Äì Speech difficulty</li>
                <li><strong>T</strong> ‚Äì Time to call emergency services</li>
              </ul>
            </div>

            <div class="bg-yellow-50 border border-yellow-200 rounded-xl p-3">
              <p class="font-semibold text-yellow-800 mb-1">üìû Call Emergency Services</p>
              <p>If you notice any of these signs, call for help immediately. Time is critical in stroke care.</p>
            </div>

            <div class="bg-blue-50 border border-blue-200 rounded-xl p-3">
              <p class="font-semibold text-blue-800 mb-1">üí° Disclaimer</p>
              <p>This app provides guidance and monitoring support, but it is <strong>not a substitute for professional medical diagnosis</strong>.</p>
            </div>

          </div>
        </div>
    </main>
    
    <footer class="bg-gray-800 text-white p-4 mt-8">
      <div class="container mx-auto text-center">
        <p>StrokeShield</p>
        <p class="text-sm mt-2">Disclaimer: This tool is for educational purposes only and not a medical diagnostic device.</p>
      </div>
    </footer>
    
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // DOM Elements
        const webcamEl = document.getElementById('webcam');
        const detectionCanvas = document.getElementById('detection-canvas');
        const canvasCtx = detectionCanvas.getContext('2d');
        const toggleButton = document.getElementById('detection-toggle');
        const clearButton = document.getElementById('clear-results');
        const faceMeshToggle = document.getElementById('face-mesh-toggle');
        const poseToggle = document.getElementById('pose-toggle');
        const symmetryLineToggle = document.getElementById('symmetry-line-toggle');
        const sensitivitySlider = document.getElementById('detection-sensitivity');
        const sensitivityValue = document.getElementById('sensitivity-value');
        
        // MediaPipe objects
        let faceMesh;
        let pose;
        let camera;
        
        // State variables
        let lastVideoTime = -1;
        let isDetecting = false;
        let showFaceMesh = true;
        let showPose = false;
        let showSymmetryLine = true;
        let sensitivity = 5;
        
        // Current facial landmarks
        let currentFaceLandmarks = null;
        let currentPoseLandmarks = null;
        
        // Store metrics for smoothing
        let metricsHistory = {
          eyeAsymmetry: [],
          mouthAsymmetry: [],
          eyebrowAsymmetry: [],
          shoulderImbalance: [],
          headTilt: [],
          bodyLean: []
        };
        
        // Default metrics values
        let currentMetrics = {
          eyeAsymmetry: 0,
          mouthAsymmetry: 0,
          eyebrowAsymmetry: 0,
          shoulderImbalance: 0,
          headTilt: 0,
          bodyLean: 0,
          overallAsymmetry: 0
        };
        
        // Max history length for smoothing
        const MAX_HISTORY = 10;
        
        // Update frequency for metrics display (ms)
        const UPDATE_INTERVAL = 500;
        let lastUpdate = 0;
        
        // Face landmark indices
        const FACE_LANDMARKS = {
          // Facial midpoint landmarks
          midline: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
          nose: [5, 6, 7, 8, 9, 168, 197, 195, 5],
          upperLip: [0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146, 61, 185, 40, 39, 37, 0],
          lowerLip: [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 409, 270, 269, 267, 0, 37, 39, 40, 185, 61],
          // Left side landmarks
          leftEye: [263, 249, 390, 373, 374, 380, 381, 382, 362, 263, 466, 388, 387, 386, 385, 384, 398, 362],
          rightEye: [33, 7, 163, 144, 145, 153, 154, 155, 133, 33, 246, 161, 160, 159, 158, 157, 173, 133],
          leftEyebrow: [276, 283, 282, 295, 285, 300, 293, 334, 296, 336],
          rightEyebrow: [46, 53, 52, 65, 55, 70, 63, 105, 66, 107],
          // Mouth corners
          leftMouthCorner: [308],
          rightMouthCorner: [78]
        };
        
        // Pose landmark indices
        const POSE_LANDMARKS = {
          leftShoulder: 11,
          rightShoulder: 12,
          leftEar: 7,
          rightEar: 8,
          nose: 0,
          leftHip: 23,
          rightHip: 24
        };
        
        // Initialize metrics chart
        const ctx = document.getElementById('metrics-chart').getContext('2d');
        const metricsChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: [
              'Eye Asymmetry', 
              'Mouth Asymmetry', 
              'Eyebrow Asymmetry', 
              'Overall Facial Asymmetry',
              'Shoulder Imbalance',
              'Head Tilt',
              'Body Lean'
            ],
            datasets: [{
              label: 'Asymmetry Metrics (%)',
              data: [0, 0, 0, 0, 0, 0, 0],
              backgroundColor: [
                'rgba(255, 99, 132, 0.6)',
                'rgba(54, 162, 235, 0.6)',
                'rgba(255, 206, 86, 0.6)',
                'rgba(75, 192, 192, 0.6)',
                'rgba(153, 102, 255, 0.6)',
                'rgba(255, 159, 64, 0.6)',
                'rgba(199, 199, 199, 0.6)'
              ],
              borderColor: [
                'rgba(255, 99, 132, 1)',
                'rgba(54, 162, 235, 1)',
                'rgba(255, 206, 86, 1)',
                'rgba(75, 192, 192, 1)',
                'rgba(153, 102, 255, 1)',
                'rgba(255, 159, 64, 1)',
                'rgba(199, 199, 199, 1)'
              ],
              borderWidth: 1
            }]
          },
          options: {
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                title: {
                  display: true,
                  text: 'Asymmetry (%)'
                }
              }
            },
            animation: {
              duration: 500
            }
          }
        });
        
        // Helper function to get average of array
        function getAverage(arr) {
          if (arr.length === 0) return 0;
          return arr.reduce((a, b) => a + b, 0) / arr.length;
        }
        
        // Add value to metrics history and maintain max length
        function addToHistory(metric, value) {
          if (!metricsHistory[metric]) {
            metricsHistory[metric] = [];
          }
          
          metricsHistory[metric].push(value);
          
          if (metricsHistory[metric].length > MAX_HISTORY) {
            metricsHistory[metric].shift();
          }
          
          return getAverage(metricsHistory[metric]);
        }
        
        // Calculate distance between two 3D points
        function distance3D(a, b) {
          return Math.sqrt(
            Math.pow(a.x - b.x, 2) + 
            Math.pow(a.y - b.y, 2) + 
            Math.pow(a.z - b.z, 2)
          );
        }
        
        // Calculate distance between two 2D points
        function distance2D(a, b) {
          return Math.sqrt(
            Math.pow(a.x - b.x, 2) + 
            Math.pow(a.y - b.y, 2)
          );
        }
        
        // Find the midpoint between two points
        function midpoint(a, b) {
          return {
            x: (a.x + b.x) / 2,
            y: (a.y + b.y) / 2,
            z: (a.z + b.z) / 2
          };
        }
        
        // Calculate asymmetry as percentage (0-1)
        function calculateAsymmetry(leftSide, rightSide) {
          // If sides aren't equal, take the smaller length
          const minLength = Math.min(leftSide.length, rightSide.length);
          
          if (minLength === 0) return 0;
          
          let totalDifference = 0;
          
          for (let i = 0; i < minLength; i++) {
            const leftPoint = leftSide[i];
            const rightPoint = rightSide[i];
            totalDifference += Math.abs(leftPoint - rightPoint);
          }
          
          // Normalize by dividing by the number of points and multiplying by sensitivity factor
          return Math.min(1.0, (totalDifference / minLength) * (sensitivity / 5));
        }
        
        // Calculate facial asymmetry metrics from faceMesh landmarks
        function calculateFacialAsymmetry(landmarks) {
          if (!landmarks || landmarks.length === 0) return null;
          
          // Calculate eye asymmetry
          const leftEyeWidth = distance3D(landmarks[FACE_LANDMARKS.leftEye[0]], landmarks[FACE_LANDMARKS.leftEye[8]]);
          const rightEyeWidth = distance3D(landmarks[FACE_LANDMARKS.rightEye[0]], landmarks[FACE_LANDMARKS.rightEye[8]]);
          const leftEyeHeight = distance3D(landmarks[FACE_LANDMARKS.leftEye[4]], landmarks[FACE_LANDMARKS.leftEye[12]]);
          const rightEyeHeight = distance3D(landmarks[FACE_LANDMARKS.rightEye[4]], landmarks[FACE_LANDMARKS.rightEye[12]]);
          
          const eyeWidthAsymmetry = Math.abs(leftEyeWidth - rightEyeWidth) / Math.max(leftEyeWidth, rightEyeWidth);
          const eyeHeightAsymmetry = Math.abs(leftEyeHeight - rightEyeHeight) / Math.max(leftEyeHeight, rightEyeHeight);
          const eyeAsymmetry = (eyeWidthAsymmetry + eyeHeightAsymmetry) / 2;
          
          // Calculate mouth asymmetry (corner height difference)
          const leftMouthCorner = landmarks[FACE_LANDMARKS.leftMouthCorner[0]];
          const rightMouthCorner = landmarks[FACE_LANDMARKS.rightMouthCorner[0]];
          const mouthHeightDiff = Math.abs(leftMouthCorner.y - rightMouthCorner.y);
          const mouthWidth = distance3D(leftMouthCorner, rightMouthCorner);
          const mouthAsymmetry = mouthHeightDiff / mouthWidth;
          
          // Calculate eyebrow asymmetry
          const leftEyebrowHeight = landmarks[FACE_LANDMARKS.leftEyebrow[2]].y - landmarks[FACE_LANDMARKS.leftEyebrow[7]].y;
          const rightEyebrowHeight = landmarks[FACE_LANDMARKS.rightEyebrow[2]].y - landmarks[FACE_LANDMARKS.rightEyebrow[7]].y;
          const eyebrowAsymmetry = Math.abs(leftEyebrowHeight - rightEyebrowHeight) / Math.max(Math.abs(leftEyebrowHeight), Math.abs(rightEyebrowHeight));
          
          // Apply sensitivity factor
          const sensitivityFactor = sensitivity / 5; // normalize to 1-2 range
          
          // Return all metrics, adjusted by sensitivity
          return {
            eyeAsymmetry: Math.min(1.0, eyeAsymmetry * sensitivityFactor),
            mouthAsymmetry: Math.min(1.0, mouthAsymmetry * sensitivityFactor), 
            eyebrowAsymmetry: Math.min(1.0, eyebrowAsymmetry * sensitivityFactor)
          };
        }
        
        // Calculate posture metrics from pose landmarks
        function calculatePostureMetrics(landmarks) {
          if (!landmarks || landmarks.length === 0) return null;
          
          // Shoulder imbalance
          const leftShoulder = landmarks[POSE_LANDMARKS.leftShoulder];
          const rightShoulder = landmarks[POSE_LANDMARKS.rightShoulder];
          const shoulderHeightDiff = Math.abs(leftShoulder.y - rightShoulder.y);
          const shoulderWidth = distance2D(leftShoulder, rightShoulder);
          const shoulderImbalance = shoulderHeightDiff / shoulderWidth;
          
          // Head tilt
          const leftEar = landmarks[POSE_LANDMARKS.leftEar];
          const rightEar = landmarks[POSE_LANDMARKS.rightEar];
          const earHeightDiff = Math.abs(leftEar.y - rightEar.y);
          const earWidth = distance2D(leftEar, rightEar);
          const headTilt = earHeightDiff / earWidth;
          
          // Body lean (vertical alignment of nose relative to midpoint of hips)
          const nose = landmarks[POSE_LANDMARKS.nose];
          const leftHip = landmarks[POSE_LANDMARKS.leftHip];
          const rightHip = landmarks[POSE_LANDMARKS.rightHip];
          const hipMidpoint = midpoint(leftHip, rightHip);
          const horizontalDeviation = Math.abs(nose.x - hipMidpoint.x);
          const bodyHeight = hipMidpoint.y - nose.y;
          const bodyLean = horizontalDeviation / bodyHeight;
          
          // Apply sensitivity factor
          const sensitivityFactor = sensitivity / 5; // normalize to 1-2 range
          
          // Return all metrics, adjusted by sensitivity
          return {
            shoulderImbalance: Math.min(1.0, shoulderImbalance * sensitivityFactor), 
            headTilt: Math.min(1.0, headTilt * sensitivityFactor),
            bodyLean: Math.min(1.0, bodyLean * sensitivityFactor)
          };
        }
        
        // Initialize MediaPipe FaceMesh
        function setupFaceMesh() {
          faceMesh = new FaceMesh({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
          });
          
          faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
          
          faceMesh.onResults(onFaceMeshResults);
        }
        
        // Initialize MediaPipe Pose
        function setupPose() {
          pose = new Pose({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
          });
          
          pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
          
          pose.onResults(onPoseResults);
        }
        
        // Draw facial symmetry line
        function drawSymmetryLine(landmarks) {
          if (!landmarks || !showSymmetryLine) return;
          
          // Get facial midline points
          const topMidpoint = landmarks[10]; // Top of forehead
          const bottomMidpoint = landmarks[152]; // Bottom of chin
          
          // Draw symmetry line
          canvasCtx.beginPath();
          canvasCtx.moveTo(topMidpoint.x * detectionCanvas.width, topMidpoint.y * detectionCanvas.height);
          canvasCtx.lineTo(bottomMidpoint.x * detectionCanvas.width, bottomMidpoint.y * detectionCanvas.height);
          canvasCtx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
          canvasCtx.lineWidth = 2;
          canvasCtx.stroke();
        }
        
        // Face Mesh results handler
        function onFaceMeshResults(results) {
          if (!isDetecting) return;
          
          canvasCtx.save();
          canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
          
          if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            // Store current landmarks
            currentFaceLandmarks = results.multiFaceLandmarks[0];
            
            // Draw face mesh
            if (showFaceMesh) {
              for (const landmarks of results.multiFaceLandmarks) {
                drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, 
                              {color: '#C0C0C070', lineWidth: 1});
                drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, 
                              {color: '#FF3030', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, 
                              {color: '#30FF30', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, 
                              {color: '#FF3030', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, 
                              {color: '#30FF30', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_IRIS, 
                              {color: '#FF3030', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_IRIS, 
                              {color: '#30FF30', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, 
                              {color: '#E0E0E0', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, 
                              {color: '#E0E0E0', lineWidth: 2});
                
                // Draw symmetry line
                drawSymmetryLine(landmarks);
              }
            }
            
            // Calculate facial asymmetry
            const facialMetrics = calculateFacialAsymmetry(currentFaceLandmarks);
            if (facialMetrics) {
              // Update with smoothing
              currentMetrics.eyeAsymmetry = addToHistory('eyeAsymmetry', facialMetrics.eyeAsymmetry);
              currentMetrics.mouthAsymmetry = addToHistory('mouthAsymmetry', facialMetrics.mouthAsymmetry);
              currentMetrics.eyebrowAsymmetry = addToHistory('eyebrowAsymmetry', facialMetrics.eyebrowAsymmetry);
              
              // Update overall asymmetry
              currentMetrics.overallAsymmetry = (
                currentMetrics.eyeAsymmetry * 0.4 + 
                currentMetrics.mouthAsymmetry * 0.4 + 
                currentMetrics.eyebrowAsymmetry * 0.2
              );
              
              // Update UI at the specified interval
              const now = Date.now();
              if (now - lastUpdate > UPDATE_INTERVAL) {
                updateUI();
                lastUpdate = now;
              }
            }
          }
          
          // Draw pose results if available
          if (currentPoseLandmarks && showPose) {
            drawConnectors(canvasCtx, currentPoseLandmarks, POSE_CONNECTIONS,
                          {color: '#00FF00', lineWidth: 4});
            drawLandmarks(canvasCtx, currentPoseLandmarks,
                         {color: '#FF0000', lineWidth: 2});
          }
          
          canvasCtx.restore();
        }
        
        // Pose results handler
        function onPoseResults(results) {
          if (!isDetecting) return;
          
          if (results.poseLandmarks) {
            // Store current landmarks
            currentPoseLandmarks = results.poseLandmarks;
            
            // Calculate posture metrics
            const postureMetrics = calculatePostureMetrics(currentPoseLandmarks);
            if (postureMetrics) {
              // Update with smoothing
              currentMetrics.shoulderImbalance = addToHistory('shoulderImbalance', postureMetrics.shoulderImbalance);
              currentMetrics.headTilt = addToHistory('headTilt', postureMetrics.headTilt);
              currentMetrics.bodyLean = addToHistory('bodyLean', postureMetrics.bodyLean);
              
              // Update UI at the specified interval
              const now = Date.now();
              if (now - lastUpdate > UPDATE_INTERVAL) {
                updateUI();
                lastUpdate = now;
              }
            }
          }
        }
        
        // Update UI with current metrics
        function updateUI() {
          // Update metrics display
          document.getElementById('eye-asymmetry').textContent = (currentMetrics.eyeAsymmetry * 100).toFixed(1) + '%';
          document.getElementById('mouth-asymmetry').textContent = (currentMetrics.mouthAsymmetry * 100).toFixed(1) + '%';
          document.getElementById('eyebrow-asymmetry').textContent = (currentMetrics.eyebrowAsymmetry * 100).toFixed(1) + '%';
          document.getElementById('overall-asymmetry').textContent = (currentMetrics.overallAsymmetry * 100).toFixed(1) + '%';
          
          document.getElementById('shoulder-imbalance').textContent = (currentMetrics.shoulderImbalance * 100).toFixed(1) + '%';
          document.getElementById('head-tilt').textContent = (currentMetrics.headTilt * 100).toFixed(1) + '%';
          document.getElementById('body-lean').textContent = (currentMetrics.bodyLean * 100).toFixed(1) + '%';
          
          // Update chart
          metricsChart.data.datasets[0].data = [
            currentMetrics.eyeAsymmetry * 100, 
            currentMetrics.mouthAsymmetry * 100, 
            currentMetrics.eyebrowAsymmetry * 100, 
            currentMetrics.overallAsymmetry * 100,
            currentMetrics.shoulderImbalance * 100,
            currentMetrics.headTilt * 100,
            currentMetrics.bodyLean * 100
          ];
          metricsChart.update();
          
          // Update risk assessment
          updateRiskAssessment();
        }
        
        // Update risk assessment based on current metrics
        function updateRiskAssessment() {
          // Determine risk level based on metrics
          let riskLevel = 'low';
          let riskColor = 'bg-green-500';
          let findings = [];
          
          const LOW_THRESHOLD = 0.1;
          const MEDIUM_THRESHOLD = 0.2;
          const HIGH_THRESHOLD = 0.3;
          
          if (currentMetrics.eyeAsymmetry > HIGH_THRESHOLD || 
              currentMetrics.mouthAsymmetry > HIGH_THRESHOLD || 
              currentMetrics.overallAsymmetry > HIGH_THRESHOLD) {
            riskLevel = 'high';
            riskColor = 'bg-red-500';
            findings.push('Significant facial asymmetry detected');
            
            if (currentMetrics.eyeAsymmetry > HIGH_THRESHOLD) {
              findings.push('High eye asymmetry - possible facial drooping');
            }
            if (currentMetrics.mouthAsymmetry > HIGH_THRESHOLD) {
              findings.push('High mouth asymmetry - possible facial weakness');
            }
            
            findings.push('Multiple high-risk indicators detected. Consider seeking immediate medical evaluation.');
          } else if (currentMetrics.eyeAsymmetry > MEDIUM_THRESHOLD || 
                    currentMetrics.mouthAsymmetry > MEDIUM_THRESHOLD || 
                    currentMetrics.shoulderImbalance > MEDIUM_THRESHOLD || 
                    currentMetrics.overallAsymmetry > MEDIUM_THRESHOLD) {
            riskLevel = 'medium';
            riskColor = 'bg-yellow-500';
            findings.push('Moderate asymmetry detected');
            
            if (currentMetrics.eyeAsymmetry > MEDIUM_THRESHOLD) {
              findings.push('Moderate eye asymmetry detected');
            }
            if (currentMetrics.mouthAsymmetry > MEDIUM_THRESHOLD) {
              findings.push('Moderate mouth asymmetry detected');
            }
            if (currentMetrics.shoulderImbalance > MEDIUM_THRESHOLD) {
              findings.push('Noticeable shoulder imbalance detected');
            }
            
            findings.push('Some concerning asymmetry detected. Consider consulting a healthcare provider.');
          } else {
            findings.push('No significant asymmetry indicators detected at this time.');
            
            if (currentMetrics.eyeAsymmetry > LOW_THRESHOLD) {
              findings.push('Slight eye asymmetry detected (within normal range)');
            }
            if (currentMetrics.mouthAsymmetry > LOW_THRESHOLD) {
              findings.push('Slight mouth asymmetry detected (within normal range)');
            }
          }
          
          findings.push('Remember FAST for stroke: Face drooping, Arm weakness, Speech difficulty, Time to call emergency services.');
          
          // Update risk indicator
          const riskIndicator = document.getElementById('risk-indicator');
          riskIndicator.className = `px-4 py-2 rounded text-white font-bold text-center ${riskColor}`;
          
          if (riskLevel === 'high') {
            riskIndicator.textContent = 'High Risk - Seek Medical Attention';
          } else if (riskLevel === 'medium') {
            riskIndicator.textContent = 'Medium Risk - Consider Medical Consultation';
          } else {
            riskIndicator.textContent = 'Low Risk - Continue Monitoring';
          }
          
          // Update findings list
          const findingsList = document.getElementById('findings-list');
          findingsList.innerHTML = '';
          findings.forEach(finding => {
            const li = document.createElement('li');
            li.textContent = finding;
            li.className = 'mb-1';
            findingsList.appendChild(li);
          });
        }
        
        // Toggle detection button
        toggleButton.addEventListener('click', function() {
          isDetecting = !isDetecting;
          if (isDetecting) {
            startCamera();
            this.textContent = 'Stop Detection';
            this.classList.remove('bg-green-500');
            this.classList.add('bg-red-500');
          } else {
            stopCamera();
            this.textContent = 'Start Detection';
            this.classList.remove('bg-red-500');
            this.classList.add('bg-green-500');
          }
        });
        
        // Clear results button
        clearButton.addEventListener('click', function() {
          // Reset metrics displays
          document.getElementById('eye-asymmetry').textContent = 'N/A';
          document.getElementById('mouth-asymmetry').textContent = 'N/A';
          document.getElementById('eyebrow-asymmetry').textContent = 'N/A';
          document.getElementById('overall-asymmetry').textContent = 'N/A';
          document.getElementById('shoulder-imbalance').textContent = 'N/A';
          document.getElementById('head-tilt').textContent = 'N/A';
          document.getElementById('body-lean').textContent = 'N/A';
          
          // Reset risk indicator
          document.getElementById('risk-indicator').className = 'px-4 py-2 rounded text-white font-bold text-center bg-gray-500';
          document.getElementById('risk-indicator').textContent = 'Awaiting Analysis';
          
          // Reset findings
          document.getElementById('findings-list').innerHTML = '<li>No findings yet. Start detection to analyze facial asymmetry and posture.</li>';
          
          // Reset chart
          metricsChart.data.datasets[0].data = [0, 0, 0, 0, 0, 0, 0];
          metricsChart.update();
          
          // Reset metrics history
          metricsHistory = {
            eyeAsymmetry: [],
            mouthAsymmetry: [],
            eyebrowAsymmetry: [],
            shoulderImbalance: [],
            headTilt: [],
            bodyLean: []
          };
          
          // Reset current metrics
          currentMetrics = {
            eyeAsymmetry: 0,
            mouthAsymmetry: 0,
            eyebrowAsymmetry: 0,
            shoulderImbalance: 0,
            headTilt: 0,
            bodyLean: 0,
            overallAsymmetry: 0
          };
          
          // Clear canvas
          canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
        });
        
        // Face mesh toggle
        faceMeshToggle.addEventListener('change', function() {
          showFaceMesh = this.checked;
          if (!showFaceMesh) {
            // Clear the canvas if needed
            if (!showPose) {
              canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            }
          }
        });
        
        // Pose toggle
        poseToggle.addEventListener('change', function() {
          showPose = this.checked;
          if (!showPose) {
            // Clear the canvas if needed
            if (!showFaceMesh) {
              canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            }
          }
        });
        
        // Symmetry line toggle
        symmetryLineToggle.addEventListener('change', function() {
          showSymmetryLine = this.checked;
        });
        
        // Sensitivity slider
        sensitivitySlider.addEventListener('input', function() {
          sensitivity = parseInt(this.value);
          sensitivityValue.textContent = sensitivity;
        });
        
        function startCamera() {
          setupFaceMesh();
          setupPose();
          
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
              .then(function(stream) {
                webcamEl.srcObject = stream;
                
                // Set up camera utilities
                camera = new Camera(webcamEl, {
                  onFrame: async () => {
                    if (showFaceMesh) {
                      await faceMesh.send({image: webcamEl});
                    }
                    
                    if (showPose) {
                      await pose.send({image: webcamEl});
                    }
                  },
                  width: 640,
                  height: 480
                });
                
                camera.start();
              })
              .catch(function(error) {
                console.error('Could not access the camera: ', error);
                alert('Could not access the camera. Please check your permissions.');
              });
          } else {
            alert('Your browser does not support camera access. Please try a different browser.');
          }
        }
        
        function stopCamera() {
          if (camera) {
            camera.stop();
          }
          
          if (webcamEl.srcObject) {
            webcamEl.srcObject.getTracks().forEach(track => track.stop());
            webcamEl.srcObject = null;
          }
          
          // Clear canvas
          canvasCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
        }
      });
    </script>
  </body>
</html>
